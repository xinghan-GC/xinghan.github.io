<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第二讲 GPIO输出</title>
      <link href="/2025/02/11/2025-2-11/"/>
      <url>/2025/02/11/2025-2-11/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul><li>GPIO（General Purpose Input Output）通用输入输出口；</li><li>可配置为8种输入输出模式；</li><li>引脚电平：0V~3.3V，部分引脚可容忍5V（可接受输入）；</li><li>输出模式下可以控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等；</li><li>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接受数据等。</li></ul><h1 id="二、GPIO位结构"><a href="#二、GPIO位结构" class="headerlink" title="二、GPIO位结构"></a>二、GPIO位结构</h1><ul><li>右侧的两个保护二极管：<strong>用于限幅电压</strong>，当输入电压大于3.3V时，导通上方的二极管，保护电路，当电压小于0V时，则会导通下方的二极管；</li><li>输入驱动器：闭合上面的开关就是上拉输入模式，闭合下面的开关就是下拉输入模式，如果都断开则就是浮空模式。为了<strong>避免引脚悬空导致输入不确定</strong>，需要在这里加上上拉或者下拉电阻，上拉模式默认高电平，下拉电阻默认低电平，由于电阻较大，这里是弱上拉和弱下拉；</li><li>肖特基触发器：这里存在翻译错误，内部符合<strong>施密特触发器</strong>，对输入电压进行整形，如果输入大于某一阈值，则输出高电平，若输入小于某一阈值，则输入低电平，在阈值范围内则保持原有电平不会变化；</li><li>模拟输入：连接到ADC上面，接收<strong>模拟量</strong>；</li><li>复用功能输入：连接其他需要读取的端口外设上，例如串口输入引脚，接收<strong>数字量</strong>；</li><li>输出控制寄存器：普通IO口输出，写这个数据寄存器的某一位就可以操作对应的端口</li><li>位设置&#x2F;清除寄存器：可以单独操作输出数据寄存器的某一位，而不影响其他位，由于输入输出寄存器是同时控制十六位的输出，想要改变某一位，一种方法是通过读出寄存器的数据，再进行<strong>按位与</strong>或者<strong>按位或</strong>，另一种方法则是通过通过位设置和位清楚寄存器来实现，如果对某一位进行置一操作，则在位设置寄存器对应位置一，其他位置零，如果对某一位进行置零操作，则在位清除寄存器对应位置置一，其他位置置零。</li><li>两个MOS管：一种电子开关，在<strong>推挽（强推）模式</strong>下，P-MOS和N-MOS均有效果，在数据寄存器为1时，上管导通，下管断开，输出高电平，数据寄存器为0时，上管断开，下管导通，输出直接接到VSS，输出低电平，<strong>开漏模式</strong>下，只有N-MOS在工作，数据寄存器为1时，下管断开，输出相当于断开，高阻模式，数据寄存器为0时，下管导通，接到VSS输出低电平，可以用作通信协议的驱动方式，还可用作输出5V电压，在<strong>关闭模式</strong>下，两个MOS管均失效，端口的电平由外部信号控制。</li></ul><h1 id="三、GPIO模式"><a href="#三、GPIO模式" class="headerlink" title="三、GPIO模式"></a>三、GPIO模式</h1><table><thead><tr><th align="center">模式名称</th><th align="center">性质</th><th align="center">特征</th></tr></thead><tbody><tr><td align="center">浮空模式</td><td align="center">数字输入</td><td align="center">可读取引脚电平，若引脚悬空，则电平不确定，端口要接上一个连续的驱动元</td></tr><tr><td align="center">上拉输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td></tr><tr><td align="center">下拉输入</td><td align="center">数字输入</td><td align="center">可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td></tr><tr><td align="center">模拟输入</td><td align="center">模拟输入</td><td align="center">GPIO无效，引脚直接接入内部ADC</td></tr><tr><td align="center">开漏输出</td><td align="center">数字输入</td><td align="center">可输出引脚电平，高电平为高阻态，低电平接VSS</td></tr><tr><td align="center">推免输出</td><td align="center">数字输入</td><td align="center">可输出引脚电平，高电平接VDD，低电平接VSS（在输出模式下，输入正常，但是输入模式下，输出断开）</td></tr><tr><td align="center">复用开漏输出</td><td align="center">数字输入</td><td align="center">由片上外设控制，高电平为高阻态，低电平接VSS</td></tr><tr><td align="center">复用推免输出</td><td align="center">数字输入</td><td align="center">由片上外设控制，高电平接VSS，低电平接VDD</td></tr></tbody></table><h1 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h1><ul><li><img src="/source/images/%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="端口配置寄存器.png"><br>GPIO的输出速度：可以限制输出引脚的最大翻转速度，为了低功耗和稳定性，一般配置成50MHz</li><li><img src="/source/images/%E7%AB%AF%E5%8F%A3%E8%AE%BE%E7%BD%AEor%E6%B8%85%E9%99%A4.jpeg" alt="端口设置or清除.png"><br>高十六位进行位清除，第十六位进行位设置，除此之外还有一个位清除寄存器，方便对单个位进行设置或者清除，若同步要求较高时，则使用上图的寄存器，其他时候可以利用两个寄存器同时配置低十六位方便操作。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第三讲 LED闪烁&amp;LED流水灯&amp;蜂鸣器</title>
      <link href="/2025/02/11/2025-2-13/"/>
      <url>/2025/02/11/2025-2-13/</url>
      
        <content type="html"><![CDATA[<h1 id="一、LED闪烁"><a href="#一、LED闪烁" class="headerlink" title="一、LED闪烁"></a>一、LED闪烁</h1><ul><li>操作STM32的GPIO步骤：<ol><li>使用RCC开启GPIO的时钟</li><li>使用GPIO_Init函数初始化GPIO</li><li>使用输入或者输出函数控制GPIO口</li></ol></li><li>在RCC的头文件最下方，我们可以找到关于RCC所有声明的函数，其中最常用的三个RCC AHB外设时钟控制，RCC APB1外设时钟控制，RCC APB2外设时钟控制<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure></li><li>GPIO的库函数：</li></ul><ol><li>GPIO_DeInit<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>; <span class="comment">//参数可写入GPIOA、GPIOB等等，用于复位指定GPIO</span></span><br></pre></td></tr></table></figure></li><li>GPIO_AFIODeInit<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//用于复位AFIO</span></span><br></pre></td></tr></table></figure></li><li>GPIO_Init<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">//用结构体参数来初始化GPIO口，需要先定义并赋值结构体，通过读取结构体的值来初始化GPIO口</span></span><br></pre></td></tr></table></figure></li><li>GPIO_StructInit<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">//可以把结构体变量赋一个默认值</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>源码编写：<ol><li>首先是采用APB2外设时钟控制</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.</span></span><br><span class="line"><span class="comment">  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.</span></span><br><span class="line"><span class="comment">  *   This parameter can be any combination of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,</span></span><br><span class="line"><span class="comment">  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,</span></span><br><span class="line"><span class="comment">  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,</span></span><br><span class="line"><span class="comment">  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,</span></span><br><span class="line"><span class="comment">  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,</span></span><br><span class="line"><span class="comment">  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,</span></span><br><span class="line"><span class="comment">  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11     </span></span><br><span class="line"><span class="comment">  * @param  NewState: new state of the specified peripheral clock.</span></span><br><span class="line"><span class="comment">  *   This parameter can be: ENABLE or DISABLE.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><pre><code>第一个参数是选择GPIO口，由于本次实验选择的是A0，所以第一个参数为RCC_APB2Periph_GPIOA，第  二个参数代表是否开启，直接输入ENABLE</code></pre><ol><li>初始化GPIO</li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Initializes the GPIOx peripheral according to the specified</span></span><br><span class="line"><span class="comment">  *         parameters in the GPIO_InitStruct.</span></span><br><span class="line"><span class="comment">  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that</span></span><br><span class="line"><span class="comment">  *         contains the configuration information for the specified GPIO peripheral.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br></pre></td></tr></table></figure><pre><code>  第一个参数代表所需要初始化的GPIO口，同APB2选择GPIOA，第二个参数需要定义并对结构体赋值，   所以需要先创建结构体GPIO_InitTypeDef GPIO_InitStructure，同时分别引出结构体的成员，分别  为GPIO_InitStructure.GPIO_Mode；GPIO_InitStructure.GPIO_Pin；  GPIO_InitStructure.GPIO_Speed，下面便详细说明三个成员赋值所代表的含义</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> GPIO_Mode_AIN = <span class="number">0x0</span>,<span class="comment">//Analog IN 模拟输入</span></span><br><span class="line">  GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,<span class="comment">//浮空输入</span></span><br><span class="line">  GPIO_Mode_IPD = <span class="number">0x28</span>,<span class="comment">//In Pull Down 下拉输入</span></span><br><span class="line">  GPIO_Mode_IPU = <span class="number">0x48</span>,<span class="comment">//In Pull Down 上拉输入</span></span><br><span class="line">  GPIO_Mode_Out_OD = <span class="number">0x14</span>,<span class="comment">//Out Open Drain 开漏输出</span></span><br><span class="line">  GPIO_Mode_Out_PP = <span class="number">0x10</span>,<span class="comment">//Out Push Pull 推免输出</span></span><br><span class="line">  GPIO_Mode_AF_OD = <span class="number">0x1C</span>,<span class="comment">//Alt Open Drain 复用开漏 </span></span><br><span class="line">  GPIO_Mode_AF_PP = <span class="number">0x18</span><span class="comment">//Alt Push Pull 复用推挽 </span></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure><pre><code> 首先是GPIO_InitStructure.GPIO_Mode，因为此次点灯我们选择推挽输出所以赋值为 GPIO_Mode_Out_PP</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_0                 ((uint16_t)0x0001)  <span class="comment">/*!&lt; Pin 0 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_1                 ((uint16_t)0x0002)  <span class="comment">/*!&lt; Pin 1 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_2                 ((uint16_t)0x0004)  <span class="comment">/*!&lt; Pin 2 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_3                 ((uint16_t)0x0008)  <span class="comment">/*!&lt; Pin 3 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_4                 ((uint16_t)0x0010)  <span class="comment">/*!&lt; Pin 4 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_5                 ((uint16_t)0x0020)  <span class="comment">/*!&lt; Pin 5 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6                 ((uint16_t)0x0040)  <span class="comment">/*!&lt; Pin 6 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7                 ((uint16_t)0x0080)  <span class="comment">/*!&lt; Pin 7 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8                 ((uint16_t)0x0100)  <span class="comment">/*!&lt; Pin 8 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_9                 ((uint16_t)0x0200)  <span class="comment">/*!&lt; Pin 9 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_10                ((uint16_t)0x0400)  <span class="comment">/*!&lt; Pin 10 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_11                ((uint16_t)0x0800)  <span class="comment">/*!&lt; Pin 11 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_12                ((uint16_t)0x1000)  <span class="comment">/*!&lt; Pin 12 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_13                ((uint16_t)0x2000)  <span class="comment">/*!&lt; Pin 13 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_14                ((uint16_t)0x4000)  <span class="comment">/*!&lt; Pin 14 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_15                ((uint16_t)0x8000)  <span class="comment">/*!&lt; Pin 15 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_All               ((uint16_t)0xFFFF)  <span class="comment">/*!&lt; All pins selected */</span></span></span><br></pre></td></tr></table></figure><pre><code> 第二项配置GPIO_InitStructure.GPIO_Pin，因为我们选择的是A0口，所以赋值为GPIO_Pin_0</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  GPIO_Speed_10MHz = <span class="number">1</span>,</span><br><span class="line">  GPIO_Speed_2MHz, </span><br><span class="line">  GPIO_Speed_50MHz</span><br><span class="line">&#125;GPIOSpeed_TypeDef;</span><br></pre></td></tr></table></figure><pre><code> 第三项配置GPIO_InitStructure.GPIO_Speed，这一项代表输出速度，50MHz即可</code></pre><p>接着将结构体的地址放入初始化函数的第二个参数，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><ol><li>GPIO的输出函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br></pre></td></tr></table></figure><pre><code> GPIO_SetBits函数可以把指定的端口设定高电平（参数为指定对应端口） GPIO_ResetBits函数可以把指定端口设定为低电平 GPIO_WriteBit根据第三个参数的值来指定端口 GPIO_Write可以同时对对应GPIO的十六个口进行写入操作</code></pre><p>首先我们先看GPIO_SetBits函数的使用，函数说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Clears the selected data port bits.</span></span><br><span class="line"><span class="comment">  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_Pin: specifies the port bits to be written.</span></span><br><span class="line"><span class="comment">  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line">  </span><br><span class="line">  GPIOx-&gt;BRR = GPIO_Pin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 第一个参数用来选择对应的GPIO，第二个参数选择GPIO对应的口，将对应的IO口置高电平</code></pre><p>GPIO_ResetBits函数的说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Clears the selected data port bits.</span></span><br><span class="line"><span class="comment">  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_Pin: specifies the port bits to be written.</span></span><br><span class="line"><span class="comment">  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line">  </span><br><span class="line">  GPIOx-&gt;BRR = GPIO_Pin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 参数选择同GPIO_SetBits函数一样，只是将对应IO口低电平</code></pre><p>GPIO_WriteBit函数说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Sets or clears the selected data port bit.</span></span><br><span class="line"><span class="comment">  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_Pin: specifies the port bit to be written.</span></span><br><span class="line"><span class="comment">  *   This parameter can be one of GPIO_Pin_x where x can be (0..15).</span></span><br><span class="line"><span class="comment">  * @param  BitVal: specifies the value to be written to the selected bit.</span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the BitAction enum values:</span></span><br><span class="line"><span class="comment">  *     @arg Bit_RESET: to clear the port pin</span></span><br><span class="line"><span class="comment">  *     @arg Bit_SET: to set the port pin</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));</span><br><span class="line">  assert_param(IS_GPIO_BIT_ACTION(BitVal)); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (BitVal != Bit_RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    GPIOx-&gt;BSRR = GPIO_Pin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    GPIOx-&gt;BRR = GPIO_Pin;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 前个两参数同上，第三个参数可以进行赋值，如果赋值Bit_RESET默认低电平，赋值Bit_SET默认高电 平</code></pre><ul><li>为了是实现LED的闪烁，需要编写延时(Delay)函数，这里直接将源码给出：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  微秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xus 延时时长，范围：0~233015</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> xus)</span></span><br><span class="line">&#123;</span><br><span class="line">SysTick-&gt;LOAD = <span class="number">72</span> * xus;<span class="comment">//设置定时器重装值</span></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0x00</span>;<span class="comment">//清空当前计数值</span></span><br><span class="line">SysTick-&gt;CTRL = <span class="number">0x00000005</span>;<span class="comment">//设置时钟源为HCLK，启动定时器</span></span><br><span class="line"><span class="keyword">while</span>(!(SysTick-&gt;CTRL &amp; <span class="number">0x00010000</span>));<span class="comment">//等待计数到0</span></span><br><span class="line">SysTick-&gt;CTRL = <span class="number">0x00000004</span>;<span class="comment">//关闭定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  毫秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xms 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(xms--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_us(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xs 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> xs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(xs--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样我们就可以实现LED的闪烁，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);</span><br><span class="line">  Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、LED流水灯"><a href="#二、LED流水灯" class="headerlink" title="二、LED流水灯"></a>二、LED流水灯</h1><ul><li>在编写流水灯的时候要采用GPIO_Write函数，它可以直接对对应GPIO口进行配置，例如本次首先需要让A0口所连接的LED点亮，则需要使A0口配置低电平，其他口配置高电平所以对应的十六位应该是1111 1111 1111 1110，就相当于0000 0000 0000 0001进行取反操作，想让A1口的LED点亮就需要配置为0000 0000 0000 0010取反，同时在每个LED点亮的中间进行延时配置，就可以写出如下代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0001</span>); <span class="comment">//0000 0000 0000 0001</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0002</span>); <span class="comment">//0000 0000 0000 0010</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0004</span>); <span class="comment">//0000 0000 0000 0100</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0008</span>); <span class="comment">//0000 0000 0000 1000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0010</span>); <span class="comment">//0000 0000 0001 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0020</span>); <span class="comment">//0000 0000 0010 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0040</span>); <span class="comment">//0000 0000 0100 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0080</span>); <span class="comment">//0000 0000 1000 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、蜂鸣器"><a href="#三、蜂鸣器" class="headerlink" title="三、蜂鸣器"></a>三、蜂鸣器</h1><ul><li>再有了上述两个程序的基础，蜂鸣器的配置其实就非常简单了，将对应的GND，3.3V高电平正确连接以后，我们本次采用B12口控制蜂鸣器，初始化对应的GPIOB，并且将12号口进行初始化，可以写出如下程序：</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_12); <span class="comment">//0000 0000 0000 0001</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_12); <span class="comment">//0000 0000 0000 0010</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_12); <span class="comment">//0000 0000 0000 0001</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_12); <span class="comment">//0000 0000 0000 0010</span></span><br><span class="line">Delay_ms(<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一讲 STM32新建工程</title>
      <link href="/2025/01/31/2025-1-31/"/>
      <url>/2025/01/31/2025-1-31/</url>
      
        <content type="html"><![CDATA[<h1 id="一、stm32的开发方式"><a href="#一、stm32的开发方式" class="headerlink" title="一、stm32的开发方式"></a>一、stm32的开发方式</h1><ol><li>基于寄存器（由于stm32较为复杂不推荐此方法）</li><li>基于标准库（寄存器封装较好）</li><li>基于<a href="%E7%89%A9%E8%81%94%E7%BD%91%E5%B5%8C%E5%85%A5%E5%BC%8F">HAL库</a>（快速上手无法了解底层逻辑）<br><em>本次学习将采用标准库的方式来学习</em></li></ol><h1 id="二、库函数"><a href="#二、库函数" class="headerlink" title="二、库函数"></a>二、库函数</h1><ol><li>打开固件库</li><li>Libraries中的就是库函数的文件</li><li>Project是官方提供的示例（可以为使用库函数做参考）</li><li>Utilities是测试电路文件</li></ol><h1 id="三、新建文件夹"><a href="#三、新建文件夹" class="headerlink" title="三、新建文件夹"></a>三、新建文件夹</h1><h2 id="1、建立启动文件夹"><a href="#1、建立启动文件夹" class="headerlink" title="1、建立启动文件夹"></a>1、建立启动文件夹</h2><ul><li>打开Kiel 5，点击新建工程</li><li>创建文件夹<a href="%E7%89%A9%E8%81%94%E7%BD%91%E5%B5%8C%E5%85%A5%E5%BC%8F">STM32</a> ——2-1 STM32工程模板，创建Project工程文件</li><li>打开固件库（以下为需要的启动文件路径）STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm</li><li>将arm文件夹内的文件复制，并在工程模板文件夹内创建start文件夹粘贴</li><li>在STM32F10x文件夹中存放了stm32f10.h和两个system文件，前者为STM32的外设寄存器描述文件（类似于51单片机的头文件），后者主要用于配置时钟。将他们复制到start文件夹中</li><li>由于STM32是由内核和外围的设备组成，且不存放在一起，所以需要添加内核寄存器的描述文件，在固件库中按以下路径找到文件，并复制粘贴到start文件夹中<br>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport</li></ul><h2 id="2、添加启动文件"><a href="#2、添加启动文件" class="headerlink" title="2、添加启动文件"></a>2、添加启动文件</h2><ul><li>选中source group1文件夹，点击文件夹前面的图标，更改名字为start文件夹，右击添加已经存在的文件，将原来start文件夹中的startup_stm32f10x_md.s，core_cm3.c，core_cm3.h，stm32f10x.h，system_stm32f10x.c，system_stm32f10x.h文件添加其中（这些文件<em>只读</em>文件，无法修改其中的内容）</li><li>点击魔法棒按钮，在c&#x2F;c++中的Include Path中添加start文件夹（这样就可以保证头文件的路径）</li><li>新建User文件夹，创建main.c文件</li><li>工程选项，C&#x2F;C++，Define内定义USE_STDPERIPH_DRIVER(使用库函数必须定义)</li><li>写入一下代码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line">     </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure><h2 id="3、启动文件分类"><a href="#3、启动文件分类" class="headerlink" title="3、启动文件分类"></a>3、启动文件分类</h2><table><thead><tr><th align="center">缩写</th><th align="center">释义</th><th align="center">Flash容量</th><th align="center">型号</th></tr></thead><tbody><tr><td align="center">LD_VL</td><td align="center">小容量产品超值系列</td><td align="center">16-32k</td><td align="center">STM32F100</td></tr><tr><td align="center">MD_VL</td><td align="center">中容量产品超值系列</td><td align="center">64-128k</td><td align="center">STM32F100</td></tr><tr><td align="center">HD_VL</td><td align="center">大容量产品超值系列</td><td align="center">256-512k</td><td align="center">STM32F100</td></tr><tr><td align="center">LD</td><td align="center">小容量产品</td><td align="center">16-32k</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">MD</td><td align="center">中容量产品</td><td align="center">64-128k</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">HD</td><td align="center">大容量产品</td><td align="center">256-512k</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">XL</td><td align="center">加大容量产品</td><td align="center">大于512k</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">CL</td><td align="center">互联型产品</td><td align="center">-</td><td align="center">STM32F105&#x2F;107</td></tr></tbody></table><h1 id="四、新建工程各文件作用"><a href="#四、新建工程各文件作用" class="headerlink" title="四、新建工程各文件作用"></a>四、新建工程各文件作用</h1><ul><li>start_xx.s：复位中断，相当于程序的入口，调用Systeminit，这个函数定义在system_xx.c&#x2F;.h里面，设置微控制器的启动，初始化嵌入式闪存接口、锁相环、更新系统内核的时钟变量。（在main函数启动之前全部执行）。还有其他中断的调用。</li><li>stm32f10_it.c&#x2F;.h：定义中断处理函数</li><li>stm32f10x.h：外设寄存器描述</li><li>core_cm3.c&#x2F;.h：内核寄存器描述</li><li>misc.c&#x2F;.h,stm32f10x_adc.c&#x2F;.h···：库函数</li><li>stm32f10x_conf.h：库函数配置</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
